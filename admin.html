<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lord William - Control Chamber</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        :root {
            --admin-bg: #000000;
            --admin-bg2: #1a0000;
            --admin-accent: #ff0000;
            --admin-accent-soft: #ff4d4d;
            --admin-text: #ffcccc;
            --admin-text-strong: #ffffff;
            --admin-border: #660000;
        }
        body { 
            background: radial-gradient(circle at top, var(--admin-bg2), var(--admin-bg)); 
            color: var(--admin-text); 
            font-family: 'Cinzel', serif;
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }
        .admin { 
            max-width: 1100px; 
            margin: 1rem auto 2rem; 
            padding: 1rem;
            width: 100%;
            box-sizing: border-box;
        }
        h1 { 
            font-size: 2rem; 
            text-shadow: 0 0 10px var(--admin-accent); 
            margin-bottom: 0.25rem; 
            color: var(--admin-text-strong); 
            line-height: 1.15;
            word-wrap: break-word;
        }
        .greet { 
            margin: 0 0 1rem; 
            font-size: 1rem; 
            color: var(--admin-text); 
            opacity: 0.9;
            word-wrap: break-word;
        }

        .grid { display: grid; grid-template-columns: 1fr; gap: 1rem; }
        @media (min-width: 900px) { .grid { grid-template-columns: 1.2fr 1fr; } }

        .panel { border: 1px solid var(--admin-border); padding: 1rem; background: rgba(255,0,0,0.05); border-radius: 10px; box-shadow: 0 6px 18px rgba(255,0,0,0.08); }
        .panel h2 { margin: 0 0 0.75rem; font-size: 1.2rem; color: var(--admin-text-strong); }

        .table-wrap { overflow-x: auto; border: 1px solid var(--admin-border); border-radius: 8px; -webkit-overflow-scrolling: touch; }
        table { width: 100%; border-collapse: collapse; min-width: 500px; }
        th, td { border-bottom: 1px solid var(--admin-border); padding: 10px; color: var(--admin-text); text-align: left; }
        th { background: rgba(255,0,0,0.12); color: var(--admin-text-strong); position: sticky; top: 0; }

        .controls { display: grid; grid-template-columns: 1fr; gap: 0.75rem; }
        @media (min-width: 600px) { .controls { grid-template-columns: repeat(2, 1fr); } }
        @media (min-width: 1100px) { .controls { grid-template-columns: 1fr; } }
        .control { border: 1px dashed var(--admin-accent-soft); padding: 0.75rem; border-radius: 8px; background: rgba(255,0,0,0.04); }
        .control label { display: block; margin-bottom: 0.5rem; color: var(--admin-text-strong); }
        .buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        button, select, input { min-height: 44px; }
        button { 
            background: var(--admin-accent); 
            color: #fff; 
            border: none; 
            padding: 0.6rem 0.9rem; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: transform .15s ease, box-shadow .15s ease; 
            font-size: 0.95rem;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 8px 18px rgba(255,0,0,0.25); }
        button:active:not(:disabled) { transform: translateY(0); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        button.secondary { background: #330000; border: 1px solid var(--admin-accent); }

        .log { 
            white-space: pre-wrap; 
            font-size: 0.95rem; 
            background: #0d0000; 
            padding: 0.75rem; 
            border-radius: 8px; 
            border: 1px solid var(--admin-border); 
            max-height: 240px; 
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            word-wrap: break-word;
        }
        
        /* Smooth scrolling */
        * {
            scroll-behavior: smooth;
        }
        
        /* Better focus states for accessibility */
        button:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--admin-accent);
            outline-offset: 2px;
        }

        /* Tablet and Medium Screens */
        @media (max-width: 768px) {
            .admin { padding: 1rem; max-width: 100%; }
            h1 { font-size: 1.8rem; }
            .greet { font-size: 1.05rem; }
            .grid { grid-template-columns: 1fr !important; gap: 1rem; }
            .panel { padding: 1.1rem; margin-bottom: 1rem; }
            .panel h2 { font-size: 1.3rem; }
            .panel h3 { font-size: 1.1rem !important; }
            .controls { grid-template-columns: 1fr !important; }
            .control label { font-size: 1.05rem; }
            .buttons { flex-wrap: wrap; gap: 0.6rem; }
            .buttons button { 
                flex: 1 1 calc(50% - 0.3rem); 
                min-width: 140px; 
                min-height: 48px;
                font-size: 1.05rem;
                padding: 0.7rem 1rem;
            }
            
            /* AI Stats responsive */
            .ai-stats-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 1rem !important;
            }
            .ai-stat-item {
                font-size: 0.95rem;
            }
            .ai-stat-item > div:first-child {
                font-size: 0.95rem !important;
                margin-bottom: 0.4rem !important;
            }
            .ai-stat-item > div:last-child {
                font-size: 1.6rem !important;
            }
            
            /* Active players list */
            .player-card {
                flex-wrap: wrap;
            }
            .player-actions {
                width: 100%;
                margin-top: 0.5rem;
            }
            .player-actions button {
                flex: 1;
                min-width: 100px;
            }
            
            /* Spectate section */
            .panel > div[style*="grid-template-columns: 1fr 1fr"] {
                grid-template-columns: 1fr !important;
            }
        }

        /* Mobile tweaks */
        @media (max-width: 480px) {
            /* Use system UI for better readability on small screens */
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; font-size: 16px; }
            h1, .panel h2 { font-family: 'Cinzel', serif; }
            .admin { 
                padding: calc(0.75rem + env(safe-area-inset-top)) 
                         calc(0.75rem + env(safe-area-inset-right)) 
                         calc(1rem + env(safe-area-inset-bottom)) 
                         calc(0.75rem + env(safe-area-inset-left)); 
                margin: 0.5rem auto 1rem; 
                max-width: 100%; 
            }
            h1 { font-size: 2rem; line-height: 1.3; margin-bottom: 0.5rem; }
            .greet { font-size: 1.1rem; margin-bottom: 1rem; }
            .panel { padding: 1.25rem; box-shadow: 0 4px 12px rgba(255,0,0,0.12); margin-bottom: 1rem; }
            .panel h2 { font-size: 1.4rem; margin-bottom: 0.75rem; }
            .panel h3 { font-size: 1.2rem !important; }
            
            .controls { grid-template-columns: 1fr !important; }
            .control { padding: 1rem; }
            .control label { font-size: 1.1rem; margin-bottom: 0.6rem; font-weight: 600; }
            .buttons { flex-direction: column; gap: 0.6rem; }
            .buttons button, .buttons select, .buttons input { 
                width: 100% !important; 
                font-size: 1.1rem; 
                min-height: 52px;
                padding: 0.75rem 1rem;
            }
            #jump-variant, #jump-duration { width: 100% !important; font-size: 1.1rem; min-height: 52px; }
            #target-player { font-size: 1.1rem !important; min-height: 52px !important; }
            
            /* AI Stats Mobile */
            #ai-stats {
                padding: 1rem !important;
            }
            #ai-stats > div[style*="grid-template-columns: repeat(2, 1fr)"] {
                grid-template-columns: 1fr !important;
                gap: 1rem !important;
            }
            #ai-stats > div[style*="grid-template-columns: repeat(2, 1fr)"] > div {
                text-align: center;
                padding: 0.5rem;
            }
            #ai-stats > div[style*="grid-template-columns: repeat(2, 1fr)"] > div > div:first-child {
                font-size: 1rem !important;
                margin-bottom: 0.5rem !important;
            }
            #ai-stats > div[style*="grid-template-columns: repeat(2, 1fr)"] > div > div:last-child {
                font-size: 2rem !important;
            }
            #ai-recent-moves {
                max-height: 150px !important;
                font-size: 0.9rem !important;
            }
            #ai-moves-list > div {
                padding: 0.4rem 0 !important;
                font-size: 0.85rem !important;
                line-height: 1.4;
            }
            
            /* Active Players List Mobile */
            #active-players-list {
                max-height: 250px !important;
            }
            #active-players-list > div {
                flex-direction: column !important;
                align-items: stretch !important;
                padding: 1rem !important;
                margin-bottom: 0.75rem !important;
            }
            #active-players-list > div > div:first-child {
                margin-bottom: 0.75rem;
                font-size: 1.1rem;
            }
            #active-players-list button {
                width: 100% !important;
                min-height: 48px !important;
                font-size: 1.1rem !important;
                padding: 0.75rem 1rem;
            }
            
            /* Table responsive */
            table { min-width: 340px; font-size: 1rem; }
            th, td { padding: 12px 8px; font-size: 1rem; }
            td.name { max-width: 150px; word-break: break-word; font-size: 1.05rem; }
            .log { font-size: 1rem; max-height: 250px; padding: 0.75rem; line-height: 1.5; }

            /* Transform table to card list */
            .table-wrap { border: none; }
            table, thead, tbody, th, td, tr { display: block; }
            thead { display: none; }
            tbody tr { 
                margin-bottom: 0.75rem; 
                border: 1px solid var(--admin-border); 
                border-radius: 8px; 
                overflow: hidden; 
                background: rgba(255,0,0,0.03); 
            }
            tbody td { 
                display: flex; 
                justify-content: space-between; 
                align-items: center;
                gap: 12px; 
                padding: 14px 16px; 
                border-bottom: 1px solid var(--admin-border);
                font-size: 1.05rem;
            }
            tbody td:last-child { border-bottom: none; }
            tbody td::before { 
                content: attr(data-col); 
                font-weight: 600; 
                color: var(--admin-text-strong);
                flex-shrink: 0;
            }
            /* Ensure action button spans full width on mobile */
            td[data-col="Actions"] { flex-direction: column; align-items: stretch; }
            td[data-col="Actions"] button { width: 100%; margin-top: 0.25rem; }

            /* Spectate mobile adjustments */
            #spectate-info { 
                font-size: 1.1rem; 
                padding: 1rem !important;
            }
            #spectate-info > div { 
                margin-bottom: 0.5rem; 
                display: flex;
                justify-content: space-between;
                font-size: 1.05rem;
            }
            #spectate-board { 
                grid-template-columns: repeat(3, 70px) !important; 
                gap: 8px !important; 
            }
            #spectate-board > div { 
                width: 70px !important; 
                height: 70px !important; 
                font-size: 28px !important;
                font-weight: bold;
            }
            
            /* Camera feed mobile adjustments */
            .spectate-grid { 
                grid-template-columns: 1fr !important; 
                gap: 0.75rem !important; 
            }
            .spectate-board-container, .spectate-camera-container-wrapper {
                width: 100%;
            }
            #spectate-board {
                margin: 0 auto !important;
            }
            #spectate-camera-container { 
                max-width: 100% !important; 
                margin: 0 auto;
            }
            #spectate-camera-feed, #camera-placeholder, #spectate-camera-canvas { 
                height: 240px !important; 
            }
            #camera-overlay {
                font-size: 1rem !important;
                padding: 0.75rem !important;
            }
            
            /* Clear spectate buttons */
            #clear-spectate, #test-camera-feed, #request-face-visible {
                width: 100% !important;
                margin: 0.5rem 0 !important;
                min-height: 52px !important;
                font-size: 1.1rem !important;
                padding: 0.75rem 1rem !important;
            }
        }
        
        /* Large screens (laptops/desktops) */
        @media (min-width: 1200px) {
            .admin { max-width: 1400px; padding: 1.5rem; }
            .grid { grid-template-columns: 1.5fr 1fr; gap: 1.5rem; }
            .panel { padding: 1.25rem; }
            h1 { font-size: 2.2rem; }
            .panel h2 { font-size: 1.3rem; }
        }
        
        /* Touch-friendly for tablets */
        @media (min-width: 481px) and (max-width: 1024px) {
            button, select, input { min-height: 48px; }
            .buttons { gap: 0.6rem; }
            .panel { padding: 1rem; }
            .ai-stats-grid { grid-template-columns: repeat(2, 1fr) !important; }
        }
        
        /* AI Stats responsive classes */
        .ai-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }
        
        .ai-stat-item {
            text-align: center;
        }
        
        @media (max-width: 480px) {
            .ai-stats-grid {
                grid-template-columns: 1fr !important;
            }
            
            .player-card {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            
            .player-actions {
                width: 100% !important;
                flex-direction: column !important;
            }
            
            .player-actions button {
                width: 100% !important;
            }
            
            .ai-moves-container {
                max-height: 120px !important;
                font-size: 0.75rem !important;
            }
            
            .active-players-container {
                max-height: 180px !important;
            }
            
            .spectate-actions {
                flex-direction: column !important;
            }
            
            .spectate-actions button {
                width: 100% !important;
                margin: 0.25rem 0 !important;
            }
        }
        
        /* Improve scrolling on mobile */
        @media (max-width: 768px) {
            .table-wrap, #ai-recent-moves, #active-players-list {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
            }
        }
        
        @media (min-width: 768px) and (max-width: 1199px) {
            .ai-stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (min-width: 1200px) {
            .ai-stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="admin">
        <h1>Welcome, Lord William</h1>
        <div class="greet">Your will binds the board. Speak, and the pieces obey.</div>

        <div class="grid">
            <div class="panel">
                <h2>AI Performance & Learning</h2>
                <div id="ai-stats" style="margin-bottom: 1rem; padding: 1rem; background: rgba(255,0,0,0.1); border-radius: 8px; border: 1px solid var(--admin-border);">
                    <div class="ai-stats-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-bottom: 0.75rem;">
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">Total Games</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--admin-text-strong);" id="ai-total-games">0</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">Win Rate</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #00ff00;" id="ai-win-rate">0%</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">AI Wins</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #00ff00;" id="ai-wins">0</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">AI Losses</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ff4444;" id="ai-losses">0</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">Player Losses</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ff8800;" id="player-losses">0</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">Draws</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ffaa00;" id="ai-draws">0</div>
                        </div>
                        <div class="ai-stat-item">
                            <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.25rem;">Adaptation Level</div>
                            <div style="font-size: 1.5rem; font-weight: bold; color: #ffaa00;" id="ai-adaptation">0%</div>
                        </div>
                    </div>
                    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--admin-border);">
                        <div style="font-size: 0.85rem; color: var(--admin-text); margin-bottom: 0.5rem;"><strong>Learning Progress:</strong></div>
                        <div style="font-size: 0.8rem; color: var(--admin-text);">
                            <div>Learned Patterns: <span id="ai-learned-patterns" style="color: #00ff00;">0</span></div>
                            <div>Blocked Patterns: <span id="ai-blocked-patterns" style="color: #00ff00;">0</span></div>
                        </div>
                    </div>
                </div>
                <div id="ai-recent-moves" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--admin-border); border-radius: 8px; padding: 0.5rem; background: rgba(0,0,0,0.3);">
                    <div style="font-size: 0.9rem; color: var(--admin-text-strong); margin-bottom: 0.5rem;">Recent AI Moves:</div>
                    <div id="ai-moves-list" style="font-size: 0.8rem; color: var(--admin-text);">
                        <div style="text-align: center; color: #666;">No moves recorded yet</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>AI Learned Patterns</h2>
                <div style="margin-bottom: 0.75rem; font-size: 0.9rem; color: var(--admin-text);">
                    Patterns the AI has learned from player wins. The AI will block these patterns in future games.
                    <br><span style="color: #00ff00; font-size: 0.85rem;">‚úì Patterns are stored persistently and survive page refreshes</span>
                </div>
                <div style="margin-bottom: 0.75rem;">
                    <button id="load-persistent-patterns" class="secondary" style="min-height: 36px; padding: 0.5rem 1rem; margin-right: 0.5rem;">Load Persistent Patterns</button>
                    <button id="clear-all-patterns" class="secondary" style="min-height: 36px; padding: 0.5rem 1rem; background: #660000;">Clear All Patterns</button>
                </div>
                <div id="learned-patterns-container" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--admin-border); border-radius: 8px; padding: 0.75rem; background: rgba(0,0,0,0.3);">
                    <div style="text-align: center; color: #666; padding: 1rem;">No patterns learned yet</div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Live Player Stats</h2>
                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Wins</th>
                                <th>Losses</th>
                                <th>Win Rate</th>
                                <th>Plays</th>
                                <th>Last Active</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="players-body"></tbody>
                    </table>
                </div>
            </div>

            <div class="panel">
                <h2>Control the Board</h2>
                <div class="controls">
                    <div class="control">
                        <label>Target Player (optional)</label>
                        <div class="buttons">
                            <input id="target-player" placeholder="Exact name or leave blank for all" style="padding:0.5rem;border-radius:6px;border:1px solid var(--admin-border);background:#1a0000;color:#fff;min-height:44px;width:100%" />
                        </div>
                    </div>
                    <div class="control">
                        <label>Difficulty</label>
                        <div class="buttons">
                            <button id="diff-easy">Easy</button>
                            <button id="diff-hard">Hard</button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Jumpscare</label>
                        <div class="buttons">
                            <select id="jump-variant" style="padding:0.5rem;border-radius:6px;border:1px solid var(--admin-border);background:#1a0000;color:#fff;">
                                <option value="left">Half Left Redout</option>
                                <option value="right">Half Right Redout</option>
                                <option value="both">Both Halves Redout</option>
                                <option value="full">Full Screen Red Flash</option>
                                <option value="demon">Demon Overlay (legacy)</option>
                            </select>
                            <input id="jump-duration" type="number" min="1000" step="500" value="3000" style="width:120px;padding:0.5rem;border-radius:6px;border:1px solid var(--admin-border);background:#1a0000;color:#fff;" />
                            <label style="display:inline-flex;align-items:center;gap:6px;">
                                <input id="jump-cheat" type="checkbox" checked /> Cheat during jumpscare
                            </label>
                            <button id="jump-now">Trigger</button>
                            <button id="jump-random">Random Jumpscares</button>
                            <button id="jump-stop" class="secondary">Stop Random</button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Move Board</label>
                        <div class="buttons">
                            <button data-move="shake">Shake</button>
                            <button data-move="left">Slide Left</button>
                            <button data-move="right">Slide Right</button>
                            <button data-move="up">Slide Up</button>
                            <button data-move="down">Slide Down</button>
                            <button data-move="center" class="secondary">Center</button>
                            <button id="shuffle-tiles">Shuffle Tiles</button>
                        </div>
                    </div>
                    <div class="control">
                        <label>Spectate Controls</label>
                        <div class="buttons">
                            <button id="pause-game">Pause</button>
                            <button id="resume-game">Resume</button>
                            <button id="hint">Hint</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel" style="margin-top: 1rem;">
            <h2>Active Players & Streams</h2>
            
            <!-- Active Players List -->
            <div id="active-players-list" style="margin-bottom: 1rem; max-height: 200px; overflow-y: auto; border: 1px solid var(--admin-border); border-radius: 8px; padding: 0.5rem;">
                <div style="padding: 0.5rem; color: var(--admin-text); font-size: 0.9rem; text-align: center;">
                    No active players
                </div>
            </div>
            
            <h2>Spectate</h2>
            <div id="spectate-info" style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,0,0,0.1); border-radius: 6px; border: 1px solid var(--admin-border);">
                <div><strong>Player:</strong> <span id="spectate-player">None</span></div>
                <div><strong>Status:</strong> <span id="spectate-status">Waiting...</span></div>
                <div><strong>Level:</strong> <span id="spectate-level">-</span></div>
                <div><strong>Round Count:</strong> <span id="spectate-round-count">-</span></div>
                <div><strong>AI Wins (Level):</strong> <span id="spectate-ai-wins">-</span></div>
                <div><strong>Player Wins (Level):</strong> <span id="spectate-player-wins">-</span></div>
                <div><strong>Tactical Claim:</strong> <span id="spectate-tactical-claim">-</span></div>
                <div><strong>Theme:</strong> <span id="spectate-theme">-</span></div>
                <div><strong>Wins:</strong> <span id="spectate-wins">0</span></div>
                <div><strong>Losses:</strong> <span id="spectate-losses">0</span></div>
                <div><strong>Jumpscare:</strong> <span id="spectate-jump">None</span></div>
                <div><strong>Camera:</strong> <span id="spectate-camera-status">Not Connected</span></div>
            </div>
            
            <!-- Admin Tactical Claim Override -->
            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(0,255,0,0.1); border-radius: 6px; border: 1px solid rgba(0,255,0,0.3);">
                <h3 style="margin: 0 0 0.5rem; font-size: 1rem; color: var(--admin-text-strong);">Admin Controls</h3>
                <button id="admin-trigger-tactical-claim" style="min-height: 36px; padding: 0.5rem 1rem; background: #00ff00; color: #000; font-weight: bold;">
                    Activate Tactical Claim
                </button>
                <div id="admin-tactical-claim-log" style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--admin-text);"></div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.75rem;">
                <div>
                    <h3 style="margin: 0 0 0.5rem; font-size: 1rem; color: var(--admin-text-strong);">Game Board</h3>
            <div id="spectate-board" style="display:grid;grid-template-columns:repeat(3,60px);gap:8px;align-items:center;justify-content:flex-start;margin:0 auto;width:fit-content;"></div>
                </div>
                <div>
                    <h3 style="margin: 0 0 0.5rem; font-size: 1rem; color: var(--admin-text-strong);">Live Camera Feed</h3>
                    <div id="spectate-camera-container" style="position: relative; width: 100%; max-width: 300px; margin: 0 auto; border: 2px solid var(--admin-border); border-radius: 8px; overflow: hidden; background: #000;">
                        <video id="spectate-camera-feed" autoplay muted playsinline webkit-playsinline style="width: 100%; height: 200px; object-fit: cover; background: #000; display: none; border: 1px solid #ff0000;"></video>
                        <canvas id="spectate-camera-canvas" style="width: 100%; height: 200px; object-fit: cover; background: #000; display: none; border: 1px solid #ff0000;"></canvas>
                        <img id="spectate-camera-image" style="width: 100%; height: 200px; object-fit: cover; background: #000; display: none; border: 1px solid #ff0000; image-rendering: auto;" crossorigin="anonymous" />
                        <div id="camera-placeholder" style="width: 100%; height: 200px; background: #000; display: flex; align-items: center; justify-content: center; color: #666; font-size: 0.9rem;">
                            No Camera Feed
                        </div>
                        <div id="camera-overlay" style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: white; padding: 0.5rem; text-align: center; font-size: 0.9rem;">
                            <span id="camera-status-text">No Camera Feed</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 0.75rem; text-align: center;">
                <button id="clear-spectate" class="secondary" style="min-height: 36px; padding: 0.5rem 1rem;">Clear Spectate</button>
                <button id="test-camera-feed" class="secondary" style="min-height: 36px; padding: 0.5rem 1rem; margin-left: 0.5rem;">Test Camera Feed</button>
                <button id="request-face-visible" style="min-height: 36px; padding: 0.5rem 1rem; margin-left: 0.5rem; background: #ff6600;">Request Face Visible</button>
            </div>
        </div>

        <div class="panel" style="margin-top: 1rem;">
            <h2>Power-Up Event Feed</h2>
            <div id="powerup-event-feed" class="log" style="max-height: 200px; font-size: 0.85rem;">
                <div style="text-align: center; color: #666; padding: 0.5rem;">No power-up events yet</div>
            </div>
        </div>
        
        <div class="panel" style="margin-top: 1rem;">
            <h2>Live Feed</h2>
            <div id="live-log" class="log"></div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const playersBody = document.getElementById('players-body');
        const liveLog = document.getElementById('live-log');
        const socket = io();
        
        // Verify socket connection
        socket.on('connect', () => {
            console.log('Admin panel connected to server');
            log('Connected to server');
            
            // Register as admin for WebRTC
            socket.emit('admin-register');
            console.log('Admin registered for WebRTC');
            log('Admin registered for WebRTC streaming');
        });
        
        // Confirm admin registration and update active players list
        socket.on('active-streams', (streams) => {
            console.log('Active player streams received:', streams);
            updateActivePlayersList(streams);
            if (streams.length > 0) {
                log(`Active streams available: ${streams.map(s => s.playerName).join(', ')}`);
            } else {
                log('No active streams available');
            }
        });
        
        // Update active players list UI
        function updateActivePlayersList(streams) {
            const listContainer = document.getElementById('active-players-list');
            if (!listContainer) return;
            
            // Update active players map
            activePlayers.clear();
            streams.forEach(stream => {
                activePlayers.set(stream.playerName, {
                    socketId: stream.socketId,
                    status: 'active',
                    hasStream: webrtcConnections.has(stream.playerName)
                });
            });
            
            if (streams.length === 0) {
                listContainer.innerHTML = '<div style="padding: 0.5rem; color: var(--admin-text); font-size: 0.9rem; text-align: center;">No active players</div>';
                return;
            }
            
            listContainer.innerHTML = streams.map(stream => {
                const isViewing = currentViewingPlayer === stream.playerName;
                const hasConnection = webrtcConnections.has(stream.playerName);
                return `
                    <div class="player-card" style="
                        display: flex; 
                        align-items: center; 
                        justify-content: space-between; 
                        padding: 0.75rem; 
                        margin-bottom: 0.5rem; 
                        background: ${isViewing ? 'rgba(255,0,0,0.2)' : 'rgba(255,0,0,0.05)'}; 
                        border: 1px solid ${isViewing ? '#ff0000' : 'var(--admin-border)'}; 
                        border-radius: 6px;
                        flex-wrap: wrap;
                        gap: 0.5rem;
                    ">
                        <div style="flex: 1; min-width: 150px;">
                            <div style="font-weight: bold; color: var(--admin-text-strong); margin-bottom: 0.25rem; word-break: break-word;">
                                ${stream.playerName}
                                ${isViewing ? '<span style="color: #00ff00; margin-left: 0.5rem; font-size: 0.8rem;">‚óè VIEWING</span>' : ''}
                            </div>
                            <div style="font-size: 0.85rem; color: var(--admin-text);">
                                Status: ${hasConnection ? '<span style="color: #00ff00;">Streaming</span>' : '<span style="color: #ffaa00;">Waiting</span>'}
                            </div>
                        </div>
                        <div class="player-actions" style="display: flex; gap: 0.5rem; flex-shrink: 0;">
                            <button 
                                class="secondary" 
                                data-view-player="${encodeURIComponent(stream.playerName)}"
                                style="min-height: 36px; padding: 0.4rem 0.8rem; font-size: 0.85rem; white-space: nowrap;"
                                ${isViewing ? 'disabled' : ''}
                            >
                                ${isViewing ? 'Viewing' : 'View'}
                            </button>
                            <button 
                                class="secondary" 
                                data-remove-player="${encodeURIComponent(stream.playerName)}"
                                style="min-height: 36px; padding: 0.4rem 0.8rem; font-size: 0.85rem; background: #660000; white-space: nowrap;"
                            >
                                Remove
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Wire up buttons
            listContainer.querySelectorAll('[data-view-player]').forEach(btn => {
                btn.onclick = () => {
                    const playerName = decodeURIComponent(btn.getAttribute('data-view-player'));
                    viewPlayerStream(playerName);
                };
            });
            
            listContainer.querySelectorAll('[data-remove-player]').forEach(btn => {
                btn.onclick = () => {
                    const playerName = decodeURIComponent(btn.getAttribute('data-remove-player'));
                    removePlayerStream(playerName);
                };
            });
        }
        
        // View a specific player's stream
        function viewPlayerStream(playerName) {
            console.log('Viewing player stream:', playerName);
            log(`Switching to view: ${playerName}`);
            
            // Update current viewing player
            currentViewingPlayer = playerName;
            
            // Update target player input
            const targetInput = document.getElementById('target-player');
            if (targetInput) {
                targetInput.value = playerName;
            }
            
            // Update spectate info
            document.getElementById('spectate-player').textContent = playerName;
            
            const videoElement = document.getElementById('spectate-camera-feed');
            const placeholder = document.getElementById('camera-placeholder');
            
            // If connection exists and has stream, display it
            if (webrtcConnections.has(playerName)) {
                const peerConnection = webrtcConnections.get(playerName);
                // Try to get stream from active players map
                if (activePlayers.has(playerName) && activePlayers.get(playerName).stream) {
                    const stream = activePlayers.get(playerName).stream;
                    const currentStream = videoElement.srcObject;
                    const streamId = stream.id;
                    const currentStreamId = currentStream ? currentStream.id : null;
                    
                    // Only set srcObject if stream has changed
                    if (currentStreamId !== streamId || !currentStream) {
                        console.log(`Switching to stream for ${playerName}, stream ID: ${streamId}`);
                        
                        // Remove existing event listeners
                        videoElement.onloadedmetadata = null;
                        videoElement.onplay = null;
                        videoElement.onerror = null;
                        
                        videoElement.srcObject = stream;
                        videoElement.style.display = 'block';
                        if (placeholder) placeholder.style.display = 'none';
                        
                        // Update status
                        document.getElementById('spectate-camera-status').textContent = 'CONNECTING...';
                        document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                        document.getElementById('camera-status-text').textContent = 'Connecting...';
                        
                        // Play ONLY after metadata is loaded
                        videoElement.onloadedmetadata = () => {
                            console.log('Video metadata loaded when switching');
                            document.getElementById('spectate-camera-status').textContent = 'LIVE';
                            document.getElementById('spectate-camera-status').style.color = '#00ff00';
                            document.getElementById('camera-status-text').textContent = 'LIVE VIDEO';
                            
                            videoElement.play().catch(error => {
                                console.error('Error playing video when switching:', error);
                                if (error.name === 'NotAllowedError') {
                                    document.getElementById('spectate-camera-status').textContent = 'Click to play';
                                    const playOnClick = () => {
                                        videoElement.play().then(() => {
                                            document.getElementById('spectate-camera-status').textContent = 'LIVE';
                                            document.getElementById('spectate-camera-status').style.color = '#00ff00';
                                            videoElement.removeEventListener('click', playOnClick);
                                        }).catch(e => console.error('Play failed on click:', e));
                                    };
                                    videoElement.addEventListener('click', playOnClick, { once: true });
                                }
                            });
                        };
                    } else {
                        // Same stream - just ensure visibility
                        console.log(`Stream already set for ${playerName}`);
                        videoElement.style.display = 'block';
                        if (placeholder) placeholder.style.display = 'none';
                        document.getElementById('spectate-camera-status').textContent = 'LIVE';
                        document.getElementById('spectate-camera-status').style.color = '#00ff00';
                        document.getElementById('camera-status-text').textContent = 'LIVE VIDEO';
                    }
                    
                    log(`Switched to existing stream for ${playerName}`);
                } else {
                    // Stream might come later via ontrack
                    if (placeholder) placeholder.style.display = 'flex';
                    document.getElementById('spectate-camera-status').textContent = 'CONNECTING...';
                    document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                    document.getElementById('camera-status-text').textContent = 'Connecting...';
                    log(`Waiting for stream for ${playerName}`);
                }
            } else {
                // Request stream if available
                socket.emit('request-player-stream', { playerName });
                log(`Requesting stream for ${playerName}`);
                if (placeholder) placeholder.style.display = 'flex';
                document.getElementById('spectate-camera-status').textContent = 'WAITING...';
                document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                document.getElementById('camera-status-text').textContent = 'Waiting for stream...';
            }
            
            // Refresh active players list
            const streams = Array.from(activePlayers.entries()).map(([name, info]) => ({
                playerName: name,
                socketId: info.socketId
            }));
            updateActivePlayersList(streams);
        }
        
        // Remove/stop viewing a player's stream
        function removePlayerStream(playerName) {
            console.log('Removing player stream:', playerName);
            log(`Removing stream for ${playerName}`);
            
            // Close WebRTC connection
            if (webrtcConnections.has(playerName)) {
                webrtcConnections.get(playerName).close();
                webrtcConnections.delete(playerName);
            }
            
            // Remove from active players
            activePlayers.delete(playerName);
            
            // If this was the current viewing player, clear view
            if (currentViewingPlayer === playerName) {
                currentViewingPlayer = null;
                
                // Clear video display
                const videoElement = document.getElementById('spectate-camera-feed');
                const placeholder = document.getElementById('camera-placeholder');
                if (videoElement) {
                    // Remove event listeners before clearing
                    videoElement.onloadedmetadata = null;
                    videoElement.onplay = null;
                    videoElement.onerror = null;
                    
                    // Pause before clearing srcObject to prevent errors
                    videoElement.pause().catch(() => {});
                    videoElement.srcObject = null;
                    videoElement.style.display = 'none';
                }
                if (placeholder) placeholder.style.display = 'flex';
                
                // Clear spectate info
                document.getElementById('spectate-player').textContent = 'None';
                document.getElementById('spectate-camera-status').textContent = 'Not Connected';
                document.getElementById('camera-status-text').textContent = 'No Camera Feed';
                
                // Clear target input
                const targetInput = document.getElementById('target-player');
                if (targetInput) {
                    targetInput.value = '';
                }
            }
            
            // Refresh active players list
            const streams = Array.from(activePlayers.entries()).map(([name, info]) => ({
                playerName: name,
                socketId: info.socketId
            }));
            updateActivePlayersList(streams);
        }
        
        socket.on('disconnect', () => {
            console.log('Admin panel disconnected from server');
            log('Disconnected from server');
            
            // Close all WebRTC connections
            closeAllWebRTCConnections();
        });
        
        // AI Stats Updates
        let aiStats = {
            wins: 0,
            losses: 0,
            draws: 0,
            totalGames: 0,
            winRate: 0,
            adaptationLevel: 0,
            learnedPatterns: 0,
            blockedPatterns: 0,
            recentMoves: [],
            playerLosses: 0, // Track total player losses across all players
            patternsData: {} // Full pattern details
        };
        
        function updateAIStatsDisplay() {
            document.getElementById('ai-total-games').textContent = aiStats.totalGames || 0;
            document.getElementById('ai-win-rate').textContent = (aiStats.winRate || 0).toFixed(1) + '%';
            document.getElementById('ai-wins').textContent = aiStats.wins || 0;
            document.getElementById('ai-losses').textContent = aiStats.losses || 0;
            document.getElementById('player-losses').textContent = aiStats.playerLosses || 0;
            document.getElementById('ai-draws').textContent = aiStats.draws || 0;
            document.getElementById('ai-adaptation').textContent = (aiStats.adaptationLevel || 0) + '%';
            document.getElementById('ai-learned-patterns').textContent = aiStats.learnedPatterns || 0;
            document.getElementById('ai-blocked-patterns').textContent = aiStats.blockedPatterns || 0;
            
            // Update recent moves
            const movesList = document.getElementById('ai-moves-list');
            if (aiStats.recentMoves.length === 0) {
                movesList.innerHTML = '<div style="text-align: center; color: #666;">No moves recorded yet</div>';
            } else {
                movesList.innerHTML = aiStats.recentMoves.slice(-10).reverse().map(move => {
                    const time = new Date(move.timestamp).toLocaleTimeString();
                    return `
                        <div style="padding: 0.25rem 0; border-bottom: 1px solid rgba(255,0,0,0.1);">
                            <span style="color: #ffaa00;">[${time}]</span> 
                            Move ${move.moveIndex} - 
                            <span style="color: ${move.moveType === 'win' ? '#00ff00' : move.moveType === 'fork' ? '#ffaa00' : '#ffffff'};">${move.moveType}</span>
                            <div style="font-size: 0.75rem; color: #999; margin-top: 0.1rem;">${move.reasoning || ''}</div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        socket.on('ai-stats-update', (stats) => {
            aiStats = { ...aiStats, ...stats };
            updateAIStatsDisplay();
            updateLearnedPatternsDisplay();
            const wins = stats.wins || 0;
            const losses = stats.losses || 0;
            const draws = stats.draws || 0;
            const winRate = (stats.winRate || 0).toFixed(1);
            const adaptation = stats.adaptationLevel || 0;
            log(`ü§ñ AI Stats Updated: ${wins}W/${losses}L/${draws}D (${winRate}% win rate) - Adaptation: ${adaptation}%`);
        });
        
        // Update learned patterns display
        function updateLearnedPatternsDisplay() {
            const container = document.getElementById('learned-patterns-container');
            if (!container) return;
            
            const patternsData = aiStats.patternsData || {};
            const patternKeys = Object.keys(patternsData);
            
            if (patternKeys.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 1rem;">No patterns learned yet</div>';
                return;
            }
            
            // Sort patterns by LAST SEEN (newest first) - so new patterns appear at TOP
            const sortedPatterns = patternKeys.sort((a, b) => {
                const patternA = patternsData[a];
                const patternB = patternsData[b];
                // Most recent first (newest at top)
                return patternB.lastSeen - patternA.lastSeen;
            });
            
            container.innerHTML = sortedPatterns.map(patternKey => {
                const pattern = patternsData[patternKey];
                const moves = pattern.moves || patternKey.split('-').map(Number);
                const lastSeen = new Date(pattern.lastSeen);
                const firstSeen = new Date(pattern.firstSeen);
                const players = pattern.players || [];
                const isBlocked = pattern.isBlocked || false;
                
                // Create visual board representation
                const board = Array(9).fill('');
                moves.forEach((move, idx) => {
                    if (move >= 0 && move < 9) {
                        board[move] = idx + 1; // Number the moves in sequence
                    }
                });
                
                // Create visual board HTML
                const boardHTML = `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; width: 120px; height: 120px; background: #333; padding: 2px; border-radius: 4px;">
                        ${board.map((cell, idx) => {
                            const hasMove = cell !== '';
                            const moveNum = hasMove ? cell : '';
                            const row = Math.floor(idx / 3);
                            const col = idx % 3;
                            return `
                                <div style="
                                    background: ${hasMove ? '#ff4444' : '#222'}; 
                                    display: flex; 
                                    align-items: center; 
                                    justify-content: center; 
                                    font-weight: bold; 
                                    color: ${hasMove ? '#fff' : '#666'};
                                    font-size: ${hasMove ? '1.2rem' : '0.8rem'};
                                    border: 1px solid #444;
                                ">
                                    ${hasMove ? moveNum : `${row + 1},${col + 1}`}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                // Convert moves to readable format
                const moveDescriptions = moves.map((move, idx) => {
                    const row = Math.floor(move / 3) + 1;
                    const col = (move % 3) + 1;
                    return `Move ${idx + 1}: Row ${row}, Col ${col}`;
                });
                
                // Time ago helper
                const timeAgo = (date) => {
                    const seconds = Math.floor((Date.now() - date) / 1000);
                    if (seconds < 60) return `${seconds}s ago`;
                    const minutes = Math.floor(seconds / 60);
                    if (minutes < 60) return `${minutes}m ago`;
                    const hours = Math.floor(minutes / 60);
                    if (hours < 24) return `${hours}h ago`;
                    const days = Math.floor(hours / 24);
                    return `${days}d ago`;
                };
                
                return `
                    <div style="
                        padding: 1rem; 
                        margin-bottom: 1rem; 
                        background: ${isBlocked ? 'rgba(0,255,0,0.15)' : 'rgba(255,0,0,0.15)'}; 
                        border: 2px solid ${isBlocked ? '#00ff00' : '#ff4444'}; 
                        border-radius: 8px;
                        border-left: 6px solid ${isBlocked ? '#00ff00' : '#ff4444'};
                    ">
                        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                            <!-- Visual Board -->
                            <div style="flex-shrink: 0;">
                                ${boardHTML}
                            </div>
                            
                            <!-- Pattern Details -->
                            <div style="flex: 1; min-width: 250px;">
                                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
                                    <div style="font-weight: bold; font-size: 1.1rem; color: var(--admin-text-strong);">
                                        Pattern Sequence
                                    </div>
                                    ${isBlocked ? 
                                        '<span style="background: #00ff00; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">‚úì BLOCKED</span>' : 
                                        '<span style="background: #ffaa00; color: #000; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: bold;">‚ö† ACTIVE</span>'
                                    }
                                </div>
                                
                                <!-- Player Names (PROMINENT) -->
                                ${players.length > 0 ? `
                                    <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,255,255,0.1); border-radius: 4px;">
                                        <div style="font-size: 0.85rem; color: #999; margin-bottom: 0.25rem;">Players who used this pattern:</div>
                                        <div style="font-weight: bold; color: #ffaa00; font-size: 1rem;">
                                            ${players.map(p => `<span style="background: rgba(255,170,0,0.2); padding: 0.2rem 0.5rem; border-radius: 4px; margin-right: 0.5rem; display: inline-block; margin-bottom: 0.25rem;">${p}</span>`).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                <!-- Move Sequence -->
                                <div style="margin-bottom: 0.5rem;">
                                    <div style="font-size: 0.85rem; color: #999; margin-bottom: 0.25rem;">Move Sequence:</div>
                                    <div style="font-size: 0.9rem; color: var(--admin-text); font-family: monospace;">
                                        ${moveDescriptions.join(' ‚Üí ')}
                                    </div>
                                </div>
                                
                                <!-- Stats -->
                                <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                    <div style="font-size: 0.8rem; color: #999;">
                                        <strong style="color: #ffaa00;">Seen:</strong> ${pattern.count} time${pattern.count !== 1 ? 's' : ''}
                                    </div>
                                    <div style="font-size: 0.8rem; color: #999;">
                                        <strong style="color: #ffaa00;">Last:</strong> ${timeAgo(lastSeen)}
                                    </div>
                                    <div style="font-size: 0.8rem; color: #999;">
                                        <strong style="color: #ffaa00;">First:</strong> ${firstSeen.toLocaleDateString()}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Track player losses from board updates
        socket.on('board-update', (data) => {
            if (data && typeof data.playerLosses === 'number') {
                // Accumulate player losses (sum across all players)
                aiStats.playerLosses = Math.max(aiStats.playerLosses || 0, data.playerLosses);
                updateAIStatsDisplay();
            }
            
            // Update spectate status if player is in interactive mode
            if (data && data.inInteractiveMode) {
                const statusEl = document.getElementById('spectate-status');
                if (statusEl && data.name === document.getElementById('spectate-player')?.textContent) {
                    statusEl.textContent = 'Interactive Mode (Paused)';
                    statusEl.style.color = '#ffaa00';
                }
            }
        });
        
        // Interactive mode events
        socket.on('interactive-mode-start', (data) => {
            log(`üé≠ Interactive mode started for ${data.name} (${data.losses} losses)`);
            const statusEl = document.getElementById('spectate-status');
            if (statusEl && data.name === document.getElementById('spectate-player')?.textContent) {
                statusEl.textContent = 'Interactive Mode (Paused)';
                statusEl.style.color = '#ffaa00';
            }
        });
        
        socket.on('interactive-mode-end', (data) => {
            log(`‚úÖ Interactive mode ended for ${data.name} - Game continues`);
            const statusEl = document.getElementById('spectate-status');
            if (statusEl && data.name === document.getElementById('spectate-player')?.textContent) {
                statusEl.textContent = 'Playing';
                statusEl.style.color = '#4CAF50';
            }
        });
        
        socket.on('interactive-mode-choice', (data) => {
            const choiceEmoji = data.choice === 'yes' ? '‚úÖ' : '‚ùå';
            log(`${choiceEmoji} ${data.name} chose "${data.choice.toUpperCase()}" in interactive mode`);
        });
        
        socket.on('ai-move', (data) => {
            // Add move to recent moves
            aiStats.recentMoves.push({
                timestamp: Date.now(),
                moveIndex: data.moveIndex,
                moveType: data.moveType,
                reasoning: data.reasoning
            });
            
            // Keep only last 50 moves
            if (aiStats.recentMoves.length > 50) {
                aiStats.recentMoves.shift();
            }
            
            updateAIStatsDisplay();
        });
        
        // Load AI stats on connect
        socket.on('connect', async () => {
            try {
                const res = await fetch('/api/ai/stats');
                if (res.ok) {
                    const data = await res.json();
                    if (data.ok) {
                        aiStats = { ...aiStats, ...data.stats };
                        updateAIStatsDisplay();
                        updateLearnedPatternsDisplay();
                    }
                }
            } catch (e) {
                console.error('Error loading AI stats:', e);
            }
            
            // Also load persistent patterns from localStorage
            loadPersistentPatterns();
        });
        
        // Load persistent patterns from localStorage
        function loadPersistentPatterns() {
            try {
                const stored = localStorage.getItem('ai_learning_data');
                if (!stored) {
                    console.log('No persistent patterns found in localStorage');
                    return;
                }
                
                const storageData = JSON.parse(stored);
                if (storageData.learnedPatterns) {
                    // Convert to format expected by display function
                    const patternsData = {};
                    for (const [patternKey, patternData] of Object.entries(storageData.learnedPatterns)) {
                        patternsData[patternKey] = {
                            count: patternData.count,
                            players: patternData.players || [],
                            lastSeen: patternData.lastSeen,
                            firstSeen: patternData.firstSeen,
                            isBlocked: storageData.blockedWinPatterns && storageData.blockedWinPatterns.includes(patternKey),
                            moves: patternKey.split('-').map(Number)
                        };
                    }
                    
                    aiStats.patternsData = { ...aiStats.patternsData, ...patternsData };
                    updateLearnedPatternsDisplay();
                    log(`Loaded ${Object.keys(patternsData).length} persistent patterns from localStorage`);
                }
            } catch (e) {
                console.error('Error loading persistent patterns:', e);
                log('Error loading persistent patterns: ' + e.message);
            }
        }
        
        // Button to load persistent patterns
        document.getElementById('load-persistent-patterns').onclick = () => {
            loadPersistentPatterns();
            log('Persistent patterns reloaded');
        };
        
        // Button to clear all patterns
        document.getElementById('clear-all-patterns').onclick = () => {
            if (confirm('Are you sure you want to clear ALL learned patterns? This cannot be undone!')) {
                try {
                    localStorage.removeItem('ai_learning_data');
                    aiStats.patternsData = {};
                    updateLearnedPatternsDisplay();
                    log('All patterns cleared from localStorage');
                } catch (e) {
                    console.error('Error clearing patterns:', e);
                    log('Error clearing patterns: ' + e.message);
                }
            }
        };

        // Debug: Log all socket events
        socket.onAny((eventName, ...args) => {
            console.log('Socket event received:', eventName, args);
            if (eventName === 'live-camera-feed') {
                console.log('LIVE CAMERA FEED EVENT DETECTED!', args);
            }
        });

        // Test message handler
        socket.on('test-message', (e) => {
            console.log('TEST MESSAGE RECEIVED:', e);
            log(`Test message from ${e?.name || 'Unknown'}: ${e?.message || 'No message'}`);
        });

        function log(msg) { liveLog.innerText = msg + "\n" + liveLog.innerText; }
        function fmt(ts) { const d = new Date(ts); return d.toLocaleString(); }
        function render(players) {
            const entries = Object.entries(players).sort((a, b) => {
                // Sort by wins first, then by win rate
                const winsA = a[1].wins || 0;
                const winsB = b[1].wins || 0;
                if (winsB !== winsA) return winsB - winsA;
                
                const playsA = a[1].plays || 0;
                const playsB = b[1].plays || 0;
                const rateA = playsA > 0 ? (winsA / playsA) : 0;
                const rateB = playsB > 0 ? (winsB / playsB) : 0;
                return rateB - rateA;
            });
            
            playersBody.innerHTML = entries.map(([name, info]) => {
                const wins = info.wins || 0;
                const losses = info.losses || 0;
                const plays = info.plays || 0;
                const winRate = plays > 0 ? ((wins / plays) * 100).toFixed(1) : '0.0';
                
                return `
                <tr>
                    <td class="name" title="${name}" data-col="Name">${name}</td>
                    <td data-col="Wins" style="color: #00ff00; font-weight: bold;">${wins}</td>
                    <td data-col="Losses">${losses}</td>
                    <td data-col="Win Rate">${winRate}%</td>
                    <td data-col="Plays">${plays}</td>
                    <td data-col="Last Active">${info.lastActive ? fmt(info.lastActive) : '-'}</td>
                    <td data-col="Actions"><button class="secondary" data-del="${encodeURIComponent(name)}">Delete</button></td>
                </tr>
            `;
            }).join('');
            // Wire delete buttons
            document.querySelectorAll('[data-del]').forEach(btn => {
                btn.onclick = async () => {
                    const who = btn.getAttribute('data-del');
                    try {
                        const res = await fetch('/api/player/delete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: decodeURIComponent(who) })
                        });
                        const text = await res.text();
                        let data = {};
                        try { data = JSON.parse(text); } catch(_) {}
                        if (data && data.ok) { log(`Deleted: ${decodeURIComponent(who)}`); load(); }
                        else { log(`Delete failed for: ${decodeURIComponent(who)}`); }
                    } catch (e) { log(`Delete error for ${decodeURIComponent(who)}: ${e.message}`); }
                };
            });
        }
        async function load() {
            const res = await fetch('/api/stats');
            const data = await res.json();
            render(data.players || {});
        }
        load();

        socket.on('session-start', (e) => { log(`Started: ${e.name} @ ${fmt(e.time)}`); load(); });
        socket.on('loss', (e) => { log(`Loss: ${e.name} (total ${e.losses}) @ ${fmt(e.time)}`); load(); });
        socket.on('win', (e) => { log(`Win: ${e.name} (total ${e.wins}) @ ${fmt(e.time)}`); load(); });
        socket.on('player-deleted', (e) => { log(`Deleted: ${e.name} @ ${fmt(e.time)}`); load(); });

        function sendControl(type, value) {
            if (socket && socket.connected) {
                const target = document.getElementById('target-player')?.value?.trim();
                socket.emit('admin-control', { type: type, value: value, target: target || undefined });
                log(`Control sent (socket): ${type} ${JSON.stringify(value)}`);
                return;
            }
            fetch('/api/control', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ type: type, value: value, target: document.getElementById('target-player')?.value?.trim() || undefined }),
            })
            .then(response => response.json())
            .then(data => {
                if (data && data.ok) {
                    log(`Control sent (http): ${type} ${value}`);
                } else {
                    log(`Control failed to send: ${type} ${value}`);
                }
            })
            .catch(error => {
                log(`Control fetch failed: ${type} ${value} - ${error.message}`);
            });
        }

        // Controls
        document.getElementById('diff-easy').onclick = () => sendControl('difficulty', 'easy');
        document.getElementById('diff-hard').onclick = () => sendControl('difficulty', 'hard');

        let randomTimer = null;
        document.getElementById('jump-now').onclick = () => {
            const variant = document.getElementById('jump-variant').value;
            const duration = parseInt(document.getElementById('jump-duration').value, 10) || 3000;
            const cheat = document.getElementById('jump-cheat').checked;
            sendControl('jumpscare', { variant, duration, cheat });
        };
        document.getElementById('jump-random').onclick = () => {
            if (randomTimer) return;
            randomTimer = setInterval(() => {
                const options = ['left','right','both','full'];
                const variant = options[Math.floor(Math.random()*options.length)];
                const duration = 2000 + Math.floor(Math.random()*2000);
                sendControl('jumpscare', { variant, duration, cheat: true });
            }, 15000 + Math.random()*15000);
            log('Random jumpscares: ON');
        };
        document.getElementById('jump-stop').onclick = () => { clearInterval(randomTimer); randomTimer = null; log('Random jumpscares: OFF'); };

        document.querySelectorAll('[data-move]').forEach(btn => {
            btn.onclick = () => sendControl('move-board', btn.dataset.move);
        });
        document.getElementById('shuffle-tiles').onclick = () => sendControl('shuffle-tiles', 'all');
        document.getElementById('pause-game').onclick = () => sendControl('pause');
        document.getElementById('resume-game').onclick = () => sendControl('resume');
        document.getElementById('hint').onclick = () => sendControl('hint');

        // Clear spectate display
        document.getElementById('clear-spectate').onclick = () => {
            document.getElementById('spectate-player').textContent = 'None';
            document.getElementById('spectate-status').textContent = 'Waiting...';
            document.getElementById('spectate-wins').textContent = '0';
            document.getElementById('spectate-losses').textContent = '0';
            document.getElementById('spectate-camera-status').textContent = 'Not Connected';
            document.getElementById('spectate-board').innerHTML = '';
            
            // Reset camera display and close WebRTC connections
            const canvasElement = document.getElementById('spectate-camera-canvas');
            const imageElement = document.getElementById('spectate-camera-image');
            const videoElement = document.getElementById('spectate-camera-feed');
            const placeholder = document.getElementById('camera-placeholder');
            
            // Close all WebRTC connections
            closeAllWebRTCConnections();
            
            // Clear video element
            if (videoElement) {
                // Remove event listeners before clearing
                videoElement.onloadedmetadata = null;
                videoElement.onplay = null;
                videoElement.onerror = null;
                
                // Pause before clearing srcObject to prevent errors
                videoElement.pause().catch(() => {});
                videoElement.srcObject = null;
                videoElement.style.display = 'none';
            }
            
            canvasElement.style.display = 'none';
            imageElement.style.display = 'none';
            imageElement.src = '';
            placeholder.style.display = 'flex';
            document.getElementById('camera-status-text').textContent = 'No Camera Feed';
            
            log('Spectate cleared');
        };

        // Request face visible button
        document.getElementById('request-face-visible').onclick = () => {
            const target = document.getElementById('target-player')?.value?.trim();
            if (!target) {
                log('ERROR: Please select a target player first');
                return;
            }
            sendControl('request-face-visible', { message: 'Please show your face so the AI anti-cheat system can see you' });
            log(`Requested face visibility from ${target}`);
        };

        // Test camera feed button
        document.getElementById('test-camera-feed').onclick = () => {
            // Create a test image (red square with text)
            const canvas = document.createElement('canvas');
            canvas.width = 320;
            canvas.height = 240;
            const ctx = canvas.getContext('2d');
            
            // Draw red background
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, 320, 240);
            
            // Draw white text
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TEST CAMERA FEED', 160, 120);
            ctx.fillText(new Date().toLocaleTimeString(), 160, 150);
            
            // Convert to data URL
            const testImageData = canvas.toDataURL('image/jpeg', 0.7);
            
            // Display the test image
            const imageElement = document.getElementById('spectate-camera-image');
            const videoElement = document.getElementById('spectate-camera-feed');
            const placeholder = document.getElementById('camera-placeholder');
            
            videoElement.style.display = 'none';
            imageElement.style.display = 'block';
            placeholder.style.display = 'none';
            
            imageElement.src = testImageData;
            
            log('Test camera feed displayed');
        };

        // Spectate live board
        socket.on('spectate', (e) => {
            if (!e || !e.board) return;
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && e.name && target !== e.name) return;
            
            // Update player info
            document.getElementById('spectate-player').textContent = e.name || 'Unknown';
            if (e.inInteractiveMode) {
                document.getElementById('spectate-status').textContent = 'Interactive Mode (Paused)';
                document.getElementById('spectate-status').style.color = '#ffaa00';
            } else {
                document.getElementById('spectate-status').textContent = e.active ? 'Playing' : 'Paused';
                document.getElementById('spectate-status').style.color = e.active ? '#4CAF50' : '#ff4444';
            }
            document.getElementById('spectate-losses').textContent = e.losses || 0;
            
            // Update level visibility (Admin Dashboard Enhancement)
            if (e.currentLevel !== undefined) {
                document.getElementById('spectate-level').textContent = e.currentLevel || 1;
                document.getElementById('spectate-round-count').textContent = e.level1Wins || 0;
                // Calculate AI wins for this level (total games - player wins)
                const aiWinsForLevel = (e.totalGamesPlayed || 0) - (e.level1Wins || 0);
                document.getElementById('spectate-ai-wins').textContent = aiWinsForLevel;
                document.getElementById('spectate-player-wins').textContent = e.level1Wins || 0;
                document.getElementById('spectate-tactical-claim').textContent = e.tacticalClaimUsed ? 'Used' : 'Available';
                document.getElementById('spectate-tactical-claim').style.color = e.tacticalClaimUsed ? '#ff4444' : '#00ff00';
                document.getElementById('spectate-theme').textContent = e.currentTheme || 'light';
            }
            
            // Update camera status
            if (e.cameraEnabled) {
                document.getElementById('spectate-camera-status').textContent = 'Active';
                document.getElementById('spectate-camera-status').style.color = '#4CAF50';
                document.getElementById('camera-status-text').textContent = 'Live Feed';
            } else {
                document.getElementById('spectate-camera-status').textContent = 'Not Connected';
                document.getElementById('spectate-camera-status').style.color = '#ff4444';
                document.getElementById('camera-status-text').textContent = 'No Camera Feed';
            }
            
            if (typeof e.wins === 'number') {
                document.getElementById('spectate-wins').textContent = e.wins;
            } else if (e && e.name) {
                if (window.__spectateLastName !== e.name) {
                    window.__spectateLastName = e.name;
                    fetch('/api/player/' + encodeURIComponent(e.name))
                      .then(r => r.ok ? r.json() : null)
                      .then(data => {
                          if (data && data.ok && data.info) {
                              document.getElementById('spectate-wins').textContent = data.info.wins || 0;
                              document.getElementById('spectate-losses').textContent = data.info.losses || 0;
                          }
                      }).catch(() => {});
                }
            }
            
            // Update board with larger, more visible cells
            const cont = document.getElementById('spectate-board');
            cont.innerHTML = e.board.map((v, i) => `
                <div style="
                    width:60px;height:60px;
                    border:2px solid #ff0000;
                    display:flex;align-items:center;justify-content:center;
                    color:#ffffff;
                    font-size:24px;
                    font-weight:bold;
                    background:${v === 'X' ? 'rgba(255,0,0,0.2)' : v === 'O' ? 'rgba(0,255,0,0.2)' : 'rgba(0,0,0,0.3)'};
                    border-radius:8px;
                    box-shadow:0 2px 8px rgba(255,0,0,0.3);
                ">${v || ''}</div>
            `).join('');
        });

        // Spectate jumpscare notifications
        socket.on('spectate-jumpscare', (e) => {
            if (!e) return;
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && e.name && target !== e.name) return;
            const info = `${e.variant || 'unknown'} (${Math.max(1, Math.round((e.duration||0)/1000))}s, cheat: ${e.cheat ? 'yes' : 'no'})`;
            document.getElementById('spectate-player').textContent = e.name || 'Unknown';
            document.getElementById('spectate-jump').textContent = info;
            log(`Jumpscare on ${e.name || 'Unknown'}: ${info}`);
            const cont = document.getElementById('spectate-board');
            const oldShadow = cont.style.boxShadow;
            cont.style.boxShadow = '0 0 24px rgba(255,0,0,0.7)';
            setTimeout(() => {
                document.getElementById('spectate-jump').textContent = 'None';
                cont.style.boxShadow = oldShadow || '';
            }, Math.max(1000, e.duration || 3000));
        });

        // WebRTC Video Streaming (Like WhatsApp Video Call)
        const webrtcConnections = new Map(); // playerName -> RTCPeerConnection
        const videoElements = new Map(); // playerName -> video element
        const activePlayers = new Map(); // playerName -> { socketId, stream, status }
        let currentViewingPlayer = null; // Currently viewing player name
        
        // STUN/TURN servers configuration (same as client)
        // Using multiple STUN servers for reliability
        const rtcConfiguration = {
            iceServers: [
                // Google's free STUN servers (primary)
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                // Additional free STUN servers (backup)
                { urls: 'stun:stun.stunprotocol.org:3478' },
                // Free TURN servers for mobile/ngrok compatibility
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' },
                // For production, add TURN servers here:
                // TURN servers are needed for users behind strict firewalls/NAT
                // Example: { urls: 'turn:your-turn-server.com:3478', username: 'user', credential: 'pass' }
            ],
            iceCandidatePoolSize: 10, // Pre-gather ICE candidates for faster connection
            bundlePolicy: 'max-bundle', // Bundle RTP and RTCP
            rtcpMuxPolicy: 'require', // Require RTCP muxing
            iceTransportPolicy: 'all' // Try both relay and non-relay candidates
        };
        
        // Handle WebRTC offer from player
        socket.on('webrtc-offer', async (data) => {
            console.log('WebRTC offer received:', data);
            const { offer, playerName, socketId } = data;
            if (!offer || !playerName) {
                console.error('Invalid WebRTC offer:', data);
                log('ERROR: Invalid WebRTC offer received');
                return;
            }
            
            // Add to active players if not already there
            if (!activePlayers.has(playerName)) {
                activePlayers.set(playerName, {
                    socketId: socketId,
                    status: 'active',
                    hasStream: false
                });
            }
            
            // Update active players list
            const streams = Array.from(activePlayers.entries()).map(([name, info]) => ({
                playerName: name,
                socketId: info.socketId
            }));
            updateActivePlayersList(streams);
            
            // Only auto-display if no player is currently being viewed, or if this is the target
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && target !== playerName) {
                console.log('WebRTC offer received but filtered by target player:', target);
                log(`WebRTC offer received from ${playerName} (filtered by target: ${target})`);
                // Still create connection but don't display
            } else if (currentViewingPlayer === null) {
                // Auto-select first player if none selected
                currentViewingPlayer = playerName;
                const targetInput = document.getElementById('target-player');
                if (targetInput) targetInput.value = playerName;
            }
            
            console.log('WebRTC offer received from player:', playerName, 'Socket ID:', socketId);
            log(`WebRTC connection request from ${playerName}`);
            
            // Close existing connection if any
            if (webrtcConnections.has(playerName)) {
                webrtcConnections.get(playerName).close();
            }
            
            // Create new peer connection
            const peerConnection = new RTCPeerConnection(rtcConfiguration);
            webrtcConnections.set(playerName, peerConnection);
            
            // Handle incoming video stream
            peerConnection.ontrack = (event) => {
                console.log('Received video track from:', playerName, event);
                console.log('Streams:', event.streams);
                console.log('Track:', event.track);
                
                // Update active players map
                if (activePlayers.has(playerName)) {
                    activePlayers.get(playerName).hasStream = true;
                }
                
                // Only display if this is the current viewing player
                if (currentViewingPlayer !== playerName && currentViewingPlayer !== null) {
                    console.log(`Stream received for ${playerName}, but viewing ${currentViewingPlayer}. Storing for later.`);
                    // Store the stream but don't display it
                    if (activePlayers.has(playerName)) {
                        activePlayers.get(playerName).stream = event.streams[0] || new MediaStream([event.track]);
                    }
                    return;
                }
                
                // Set as current viewing if none selected
                if (currentViewingPlayer === null) {
                    currentViewingPlayer = playerName;
                }
                
                const videoElement = document.getElementById('spectate-camera-feed');
                const canvasElement = document.getElementById('spectate-camera-canvas');
                const imageElement = document.getElementById('spectate-camera-image');
                const placeholder = document.getElementById('camera-placeholder');
                
                if (!videoElement) {
                    console.error('Video element not found!');
                    log('ERROR: Video element not found');
                    return;
                }
                
                // Get stream from event (prefer streams array, fallback to track)
                let stream = null;
                if (event.streams && event.streams.length > 0) {
                    stream = event.streams[0];
                } else if (event.track) {
                    // Fallback: create stream from track
                    stream = new MediaStream([event.track]);
                } else {
                    console.error('No stream or track in event:', event);
                    log('ERROR: No stream or track received');
                    return;
                }
                
                // Store stream in active players for later use
                if (activePlayers.has(playerName)) {
                    activePlayers.get(playerName).stream = stream;
                }
                
                // Only update video element if stream has changed (prevent interruption)
                const currentStream = videoElement.srcObject;
                const streamId = stream.id;
                const currentStreamId = currentStream ? currentStream.id : null;
                
                // Check if this is a different stream or if video element is not set
                if (currentStreamId !== streamId || !currentStream) {
                    console.log(`Setting video stream for ${playerName}, stream ID: ${streamId}`);
                    
                    // Remove existing event listeners to prevent duplicate handlers
                    videoElement.onloadedmetadata = null;
                    videoElement.onplay = null;
                    videoElement.onerror = null;
                    
                    // Set srcObject only once per stream
                    videoElement.srcObject = stream;
                    videoElement.style.display = 'block';
                    if (canvasElement) canvasElement.style.display = 'none';
                    if (imageElement) imageElement.style.display = 'none';
                    if (placeholder) placeholder.style.display = 'none';
                    
                    // Update status immediately
                    document.getElementById('spectate-camera-status').textContent = 'CONNECTING...';
                    document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                    document.getElementById('camera-status-text').textContent = 'Connecting...';
                    document.getElementById('spectate-player').textContent = playerName;
                    
                    // Play video ONLY after metadata is loaded (prevents interruption error)
                    videoElement.onloadedmetadata = () => {
                        console.log('Video metadata loaded, dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                        
                        // Update status to LIVE
                        document.getElementById('spectate-camera-status').textContent = 'LIVE';
                        document.getElementById('spectate-camera-status').style.color = '#00ff00';
                        document.getElementById('camera-status-text').textContent = 'LIVE VIDEO';
                        
                        // Play video - only call once, after metadata is ready
                        videoElement.play().catch(error => {
                            console.error('Error playing video after metadata:', error);
                            log(`Video play error: ${error.message}`);
                            
                            // Handle autoplay restrictions gracefully
                            if (error.name === 'NotAllowedError') {
                                log('Autoplay blocked - user interaction required');
                                document.getElementById('spectate-camera-status').textContent = 'Click to play';
                                document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                                
                                // Add click handler to play on user interaction
                                const playOnClick = () => {
                                    videoElement.play().then(() => {
                                        document.getElementById('spectate-camera-status').textContent = 'LIVE';
                                        document.getElementById('spectate-camera-status').style.color = '#00ff00';
                                        videoElement.removeEventListener('click', playOnClick);
                                    }).catch(e => console.error('Play failed on click:', e));
                                };
                                videoElement.addEventListener('click', playOnClick, { once: true });
                            }
                        });
                    };
                    
                    videoElement.onplay = () => {
                        console.log('Video started playing');
                        log(`‚úÖ Video playing for ${playerName}`);
                    };
                    
                    videoElement.onerror = (e) => {
                        console.error('Video element error:', e);
                        log(`Video error for ${playerName}`);
                        document.getElementById('spectate-camera-status').textContent = 'ERROR';
                        document.getElementById('spectate-camera-status').style.color = '#ff0000';
                    };
                    
                    log(`‚úÖ Live video stream connected: ${playerName} (stream ID: ${streamId})`);
                } else {
                    // Same stream - just ensure it's visible
                    console.log(`Stream already set for ${playerName}, ensuring visibility`);
                    videoElement.style.display = 'block';
                    if (canvasElement) canvasElement.style.display = 'none';
                    if (imageElement) imageElement.style.display = 'none';
                    if (placeholder) placeholder.style.display = 'none';
                    
                    // Update status
                    document.getElementById('spectate-camera-status').textContent = 'LIVE';
                    document.getElementById('spectate-camera-status').style.color = '#00ff00';
                    document.getElementById('camera-status-text').textContent = 'LIVE VIDEO';
                    document.getElementById('spectate-player').textContent = playerName;
                }
                
                // Refresh active players list
                const streams = Array.from(activePlayers.entries()).map(([name, info]) => ({
                    playerName: name,
                    socketId: info.socketId
                }));
                updateActivePlayersList(streams);
            };
            
            // Also listen for stream events
            peerConnection.addEventListener('track', (event) => {
                console.log('Track event received:', event);
            });
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('webrtc-ice-candidate', {
                        candidate: event.candidate,
                        targetSocketId: socketId,
                        playerName: playerName
                    });
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log(`WebRTC connection state for ${playerName}:`, state);
                log(`WebRTC state: ${state} for ${playerName}`);
                
                if (state === 'connected') {
                    document.getElementById('spectate-camera-status').textContent = 'CONNECTED';
                    document.getElementById('spectate-camera-status').style.color = '#00ff00';
                    document.getElementById('camera-status-text').textContent = 'CONNECTED';
                } else if (state === 'connecting') {
                    document.getElementById('spectate-camera-status').textContent = 'CONNECTING...';
                    document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                    document.getElementById('camera-status-text').textContent = 'Connecting...';
                } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                    document.getElementById('spectate-camera-status').textContent = 'DISCONNECTED';
                    document.getElementById('spectate-camera-status').style.color = '#ff4444';
                    document.getElementById('camera-status-text').textContent = 'Disconnected';
                    
                    // Show placeholder
                    const videoElement = document.getElementById('spectate-camera-feed');
                    const placeholder = document.getElementById('camera-placeholder');
                    if (videoElement) {
                        // Remove event listeners before clearing
                        videoElement.onloadedmetadata = null;
                        videoElement.onplay = null;
                        videoElement.onerror = null;
                        
                        // Pause before clearing srcObject to prevent errors
                        videoElement.pause().catch(() => {});
                        videoElement.srcObject = null;
                        videoElement.style.display = 'none';
                    }
                    if (placeholder) placeholder.style.display = 'flex';
                    
                    log(`WebRTC connection ${state} for ${playerName}`);
                }
            };
            
            // Handle ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${playerName}:`, peerConnection.iceConnectionState);
                log(`ICE state: ${peerConnection.iceConnectionState} for ${playerName}`);
            };
            
            // Handle ICE gathering state
            peerConnection.onicegatheringstatechange = () => {
                console.log(`ICE gathering state for ${playerName}:`, peerConnection.iceGatheringState);
            };
            
            // Set remote description and create answer
            try {
                console.log('Setting remote description...');
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('Remote description set, creating answer...');
                
                // Wait a bit for ICE candidates to be gathered
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const answer = await peerConnection.createAnswer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: true  // Admin wants to receive video
                });
                console.log('Answer created, setting local description...');
                
                await peerConnection.setLocalDescription(answer);
                console.log('Local description set');
                
                // Wait for ICE candidates before sending answer
                await new Promise(resolve => {
                    if (peerConnection.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const checkState = () => {
                            if (peerConnection.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                setTimeout(checkState, 100);
                            }
                        };
                        setTimeout(checkState, 100);
                    }
                });
                
                // Send answer back to player
                socket.emit('webrtc-answer', {
                    answer: peerConnection.localDescription,
                    playerSocketId: socketId
                });
                
                console.log('WebRTC answer sent to player:', playerName, 'Socket ID:', socketId);
                log(`WebRTC answer sent to ${playerName}`);
            } catch (error) {
                console.error('Error handling WebRTC offer:', error);
                log(`ERROR setting up WebRTC for ${playerName}: ${error.message}`);
            }
        });
        
        // Handle ICE candidates from player
        socket.on('webrtc-ice-candidate', async (data) => {
            const { candidate, playerName } = data;
            if (!candidate || !playerName) return;
            
            const peerConnection = webrtcConnections.get(playerName);
            if (peerConnection) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                }
            }
        });
        
        // Handle active streams list
        socket.on('active-streams', (streams) => {
            console.log('Active player streams:', streams);
            if (streams.length > 0) {
                log(`Active streams: ${streams.map(s => s.playerName).join(', ')}`);
            }
        });
        
        // Handle player stream ended
        socket.on('player-stream-ended', (data) => {
            const { playerName } = data;
            if (playerName && webrtcConnections.has(playerName)) {
                webrtcConnections.get(playerName).close();
                webrtcConnections.delete(playerName);
                activePlayers.delete(playerName);
                log(`Stream ended for ${playerName}`);
                
                // If this was the current viewing player, clear view
                if (currentViewingPlayer === playerName) {
                    currentViewingPlayer = null;
                    const videoElement = document.getElementById('spectate-camera-feed');
                    const placeholder = document.getElementById('camera-placeholder');
                    if (videoElement) {
                        // Remove event listeners before clearing
                        videoElement.onloadedmetadata = null;
                        videoElement.onplay = null;
                        videoElement.onerror = null;
                        
                        // Pause before clearing srcObject to prevent errors
                        videoElement.pause().catch(() => {});
                        videoElement.srcObject = null;
                        videoElement.style.display = 'none';
                    }
                    if (placeholder) placeholder.style.display = 'flex';
                    document.getElementById('spectate-player').textContent = 'None';
                    document.getElementById('spectate-camera-status').textContent = 'Not Connected';
                }
                
                // Refresh active players list
                const streams = Array.from(activePlayers.entries()).map(([name, info]) => ({
                    playerName: name,
                    socketId: info.socketId
                }));
                updateActivePlayersList(streams);
            }
        });
        
        // Handle player stream available response
        socket.on('player-stream-available', (data) => {
            const { playerName } = data;
            log(`Stream available for ${playerName}`);
            // Stream should come via webrtc-offer
        });
        
        socket.on('player-stream-unavailable', (data) => {
            const { playerName } = data;
            log(`Stream unavailable for ${playerName}`);
        });
        
        // Close all WebRTC connections
        function closeAllWebRTCConnections() {
            webrtcConnections.forEach((pc, playerName) => {
                pc.close();
                console.log('Closed WebRTC connection for:', playerName);
            });
            webrtcConnections.clear();
        }

        // Camera feed streaming (legacy)
        socket.on('camera-feed', (e) => {
            if (!e || !e.imageData) {
                console.log('Invalid camera feed data:', e);
                return;
            }
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && e.name && target !== e.name) {
                console.log('Camera feed filtered out by target:', { target, playerName: e.name });
                return;
            }
            
            // Update camera status
            document.getElementById('spectate-camera-status').textContent = 'Active';
            document.getElementById('spectate-camera-status').style.color = '#4CAF50';
            document.getElementById('camera-status-text').textContent = 'Live Feed';
            
            // Display the camera feed as rapid image updates for smooth video effect
            const imageElement = document.getElementById('spectate-camera-image');
            const videoElement = document.getElementById('spectate-camera-feed');
            const placeholder = document.getElementById('camera-placeholder');
            
            // Hide video element, show image element for frame-by-frame updates
            videoElement.style.display = 'none';
            imageElement.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Update image source for smooth video effect
            imageElement.src = e.imageData;
            
            // Log periodically (not every frame to avoid spam)
            if (Math.random() < 0.02) { // 2% chance to log
                log(`Live camera feed from ${e.name || 'Unknown'}`);
            }
        });

        // Camera status updates (one-time events)
        socket.on('camera-status', (e) => {
            if (!e) return;
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && e.name && target !== e.name) return;
            
            if (e.connected) {
                document.getElementById('spectate-camera-status').textContent = 'Active';
                document.getElementById('spectate-camera-status').style.color = '#4CAF50';
                document.getElementById('camera-status-text').textContent = 'Live Feed';
            } else {
                document.getElementById('spectate-camera-status').textContent = 'Disconnected';
                document.getElementById('spectate-camera-status').style.color = '#ff4444';
                document.getElementById('camera-status-text').textContent = 'Camera Disconnected';
            }
            log(`Camera ${e.connected ? 'connected' : 'disconnected'} for ${e.name || 'Unknown'}`);
        });
        
        // Periodic camera status updates (every 3 seconds from players)
        socket.on('camera-status-update', (e) => {
            if (!e) return;
            const target = document.getElementById('target-player')?.value?.trim();
            if (target && e.name && target !== e.name) return;
            
            // Only update if this is the currently viewed player
            if (e.name === document.getElementById('spectate-player')?.textContent || !target) {
                if (e.connected && e.streamActive) {
                    document.getElementById('spectate-camera-status').textContent = 'LIVE';
                    document.getElementById('spectate-camera-status').style.color = '#00ff00';
                    document.getElementById('camera-status-text').textContent = 'Live Camera Active';
                } else if (e.hasStream && !e.streamActive) {
                    document.getElementById('spectate-camera-status').textContent = 'INACTIVE';
                    document.getElementById('spectate-camera-status').style.color = '#ffaa00';
                    document.getElementById('camera-status-text').textContent = 'Camera Inactive';
                } else {
                    document.getElementById('spectate-camera-status').textContent = 'OFF';
                    document.getElementById('spectate-camera-status').style.color = '#ff4444';
                    document.getElementById('camera-status-text').textContent = 'Camera Off';
                }
            }
            
            // Update active players list if player has camera
            if (activePlayers.has(e.name)) {
                activePlayers.get(e.name).hasCamera = e.connected && e.streamActive;
            }
        });
    </script>
</body>
</html> 